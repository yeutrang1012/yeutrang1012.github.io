<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Christmas Hands ‚Ä¢ Swipe Rotate (Preview Cam)</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --bg:#07070a;
      --glass:rgba(15,15,20,.55);
      --glass2:rgba(15,15,20,.35);
      --gold:#d8b46a;
      --gold2:#f2e3b5;
      --muted:rgba(255,255,255,.62);
    }
    *{box-sizing:border-box}
    body{
      margin:0; overflow:hidden; background:var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }
    body:before{
      content:""; position:fixed; inset:0; pointer-events:none;
      background: radial-gradient(70% 60% at 50% 50%, transparent 35%, rgba(0,0,0,.55) 100%);
      background-image: linear-gradient(to top, #e39728, #a65634, #56292a, #000000);
      z-index: 0;
    }

    #canvas-container{
      position:fixed; inset:0;
      z-index: 1;
    }

    #bg-video{
      position: fixed;
      top: 14px; right: 14px;
      width: 180px; height: 128px;
      object-fit: cover;
      transform: scaleX(-1);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      box-shadow: 0 14px 35px rgba(0,0,0,0.55);
      opacity: 0.88;
      z-index: 5;
    }

    #ui-layer{
      position:absolute; left:0; right:0; bottom:22px;
      display:flex; justify-content:center;
      padding:0 14px;
      z-index: 6;
      pointer-events:none;
    }
    .ui-card{
      pointer-events:auto;
      width:min(840px, 100%);
      background: linear-gradient(180deg, var(--glass), var(--glass2));
      border: 1px solid rgba(216,180,106,0.25);
      border-radius: 22px;
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      padding: 14px 16px;
      display:flex; align-items:center; gap:14px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid rgba(216,180,106,0.22);
      color: var(--gold2);
      background: rgba(0,0,0,0.22);
      font-weight: 650;
      letter-spacing: .2px;
      white-space: nowrap;
      min-width: 190px;
      justify-content: center;
    }
    .guide{
      flex:1;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    button{
      pointer-events:auto;
      cursor:pointer;
      border: 1px solid rgba(216,180,106,0.35);
      color: rgba(255,255,255,0.92);
      padding: 11px 18px;
      border-radius: 16px;
      font-weight: 750;
      font-size: 14px;
      letter-spacing: 0.4px;
      background: linear-gradient(180deg, rgba(122,16,32,0.95), rgba(70,10,18,0.92));
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
    }
    button:hover{
      transform: translateY(-1px);
      box-shadow: 0 16px 40px rgba(0,0,0,0.55);
      border-color: rgba(242,227,181,0.45);
    }
    button:active{ transform: translateY(0) scale(0.99); }

    #error-log{
      display:none;
      position:absolute; top:0; left:0;
      z-index: 999;
      color:#ff6b6b;
      background: rgba(0,0,0,0.75);
      padding:10px 12px;
      border-bottom-right-radius: 14px;
      max-width: 75vw;
      white-space: pre-wrap;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div id="error-log"></div>

  <video id="bg-video" class="input_video" playsinline autoplay muted></video>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <div class="ui-card">
      <div id="status" class="badge">üéÑ S·∫µn s√†ng</div>
      <div class="guide">
        üñê(1 l·∫ßn)  ‚Ä¢  Vu·ªët: Xoay  ‚Ä¢  üëå: Xem ·∫£nh  ‚Ä¢  ‚úä: D·ª´ng
      </div>
      <button id="btnStart">B·∫Øt ƒë·∫ßu</button>
    </div>
  </div>

  <script>
    const MUSIC_URL = "./audio.mp3";
    const PHOTO_FILES = ["./image1.jpeg","./image2.jpeg","./image3.jpeg","./image4.jpeg","./image5.jpeg"];

    const CONFIG = {
      goldCount: 2000,
      redCount: 300,
      giftCount: 150,
      explodeRadius: 65,
      photoOrbitRadius: 25,
      treeHeight: 70,
      treeBaseRadius: 35,

      gestureHoldMs: 170,
      transMs: 520,

      swipeSensitivity: 0.65,
      velClamp: 0.028,
      frictionPerSec: 7.0,

      FIST_IN: 0.23,
      FIST_OUT: 0.28,
      PINCH_IN: 0.045,
      PINCH_OUT: 0.060,
    };

    const STATE = { TREE:"TREE", EXPLODE:"EXPLODE", PHOTO:"PHOTO" };
    let state = STATE.TREE;
    let desiredState = STATE.TREE;
    let fromState = STATE.TREE;
    let toState = STATE.TREE;
    let transStart = performance.now();

    let active3D = false;
    let handX = 0.5;
    let lastHandX = null;
    let rotVelocity = 0;
    let handSeen = false;

    let lastGesture = "NONE";
    let stableGesture = "NONE";
    let gestureSince = performance.now();
    let prevStableGesture = "NONE";

    let scene, camera, renderer;
    let groupGold, groupRed, groupGift;
    let photoMeshes = [];
    let photoTextures = [];
    let titleMesh, starMesh;
    let selectedIndex = 0;

    let bgMusic = new Audio(MUSIC_URL);
    bgMusic.loop = true;
    bgMusic.volume = 1.0;

    function logError(e){
      const el = document.getElementById("error-log");
      el.style.display = "block";
      el.textContent += (e?.stack || e?.message || String(e)) + "\n";
      console.error(e);
    }
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const smoothstep = (t)=>t*t*(3-2*t);

    function requestState(next){
      if (next === toState) return;
      fromState = state;
      toState = next;
      transStart = performance.now();
    }
    function getTargets(geo, st){
      if (st === STATE.TREE) return geo.userData.tree;
      return geo.userData.explode;
    }

    function createCustomTexture(type) {
      const c = document.createElement('canvas');
      c.width = 128; c.height = 128;
      const ctx = c.getContext('2d');
      const cx = 64, cy = 64;

      if (type === 'gold_glow') {
        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
        g.addColorStop(0, '#FFFFFF');
        g.addColorStop(0.2, '#FFFFE0');
        g.addColorStop(0.5, '#FFD700');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,128,128);

      } else if (type === 'red_light') {
        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
        g.addColorStop(0, '#FFAAAA');
        g.addColorStop(0.3, '#FF0000');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,128,128);

      } else if (type === 'gift_red') {
        // b·∫°n ƒëang d√πng gift_red nh∆∞ ng√¥i sao ph√°t s√°ng
        const halo1 = ctx.createRadialGradient(cx, cy, 0, cx, cy, 62);
        halo1.addColorStop(0.00, 'rgba(255,255,255,1.00)');
        halo1.addColorStop(0.18, 'rgba(210,240,255,0.95)');
        halo1.addColorStop(0.45, 'rgba(130,200,255,0.55)');
        halo1.addColorStop(1.00, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo1; ctx.fillRect(0,0,128,128);

        const halo2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, 90);
        halo2.addColorStop(0.0, 'rgba(120,190,255,0.22)');
        halo2.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo2; ctx.fillRect(0,0,128,128);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.beginPath();
        const spikes = 5, outer = 24, inner = 11;
        let rot = Math.PI / 2 * 3;
        const step = Math.PI / spikes;

        ctx.moveTo(0, -outer);
        for (let i = 0; i < spikes; i++) {
          ctx.lineTo(Math.cos(rot) * outer, Math.sin(rot) * outer); rot += step;
          ctx.lineTo(Math.cos(rot) * inner, Math.sin(rot) * inner); rot += step;
        }
        ctx.closePath();
        ctx.fillStyle = '#FFFFFF';
        ctx.shadowColor = 'rgba(200,240,255,1.0)';
        ctx.shadowBlur = 26;
        ctx.fill();
        ctx.restore();
      }
      return new THREE.CanvasTexture(c);
    }

    const textures = {
      gold: createCustomTexture('gold_glow'),
      red: createCustomTexture('red_light'),
      gift: createCustomTexture('gift_red')
    };

    function init3D() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);

      groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
      groupRed  = createParticleSystem('red',  CONFIG.redCount, 3.5);
      groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);

      createPhotos();       // ‚úÖ s·ª≠a n·∫±m trong ƒë√¢y
      createDecorations();
    }

    function createParticleSystem(type, count, size) {
      const pPositions = [];
      const pExplodeTargets = [];
      const pTreeTargets = [];

      for(let i=0; i<count; i++) {
        const h = Math.random() * CONFIG.treeHeight;
        const y = h - CONFIG.treeHeight / 2;

        let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random()*0.1;
        const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
        const r = maxR * radiusRatio;
        const theta = Math.random() * Math.PI * 2;

        const tx = r * Math.cos(theta);
        const tz = r * Math.sin(theta);
        pTreeTargets.push(tx, y, tz);

        const u = Math.random();
        const v = Math.random();
        const phi = Math.acos(2*v - 1);
        const lam = 2 * Math.PI * u;

        let radMult = (type === 'gift') ? 1.2 : 1.0;
        const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;

        const ex = rad * Math.sin(phi) * Math.cos(lam);
        const ey = rad * Math.sin(phi) * Math.sin(lam);
        const ez = rad * Math.cos(phi);
        pExplodeTargets.push(ex, ey, ez);

        pPositions.push(tx, y, tz);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
      geo.userData = { tree: pTreeTargets, explode: pExplodeTargets };

      const mat = new THREE.PointsMaterial({
        size,
        map: textures[type],
        transparent: true,
        opacity: 1.0,
        blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
      });

      const points = new THREE.Points(geo, mat);
      scene.add(points);
      return points;
    }

    // ‚úÖ FIX: ·∫¢nh kh√¥ng m√©o + kh√¥ng b·ªã b√©
    function createPhotos() {
      const loader = new THREE.TextureLoader();

      // Plane 1x1, scale b·∫±ng baseScale theo t·ªâ l·ªá ·∫£nh
      const geo = new THREE.PlaneGeometry(1, 1);
      const borderGeo = new THREE.PlaneGeometry(1, 1);
      const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

      const BASE_H = 8;      // gi·ªØ chi·ªÅu cao ·∫£nh nh∆∞ b·∫°n ƒëang d√πng 8x8 tr∆∞·ªõc ƒë√≥
      const BORDER_PAD = 1.10;

      // reset
      photoMeshes.forEach(m => scene.remove(m));
      photoMeshes = [];
      photoTextures = [];

      function applyAspect(mesh, tex){
        if (!tex || !tex.image) return;
        const img = tex.image;
        const w = img.naturalWidth || img.width;
        const h = img.naturalHeight || img.height;
        if (!w || !h) return;

        const aspect = w / h;
        const baseW = BASE_H * aspect;

        // l∆∞u scale g·ªëc theo ·∫£nh (quan tr·ªçng!)
        mesh.userData.baseScale = new THREE.Vector2(baseW, BASE_H);
      }

      for(let i=0; i<5; i++) {
        const tex = loader.load(
          PHOTO_FILES[i],
          () => applyAspect(mesh, tex),
          undefined,
          (e) => console.warn("Failed:", PHOTO_FILES[i], e)
        );

        // (kh√¥ng b·∫Øt bu·ªôc cho m√©o, nh∆∞ng gi√∫p m√†u ƒë√∫ng h∆°n)
        tex.encoding = THREE.sRGBEncoding;

        const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);

        // khung: scale PAD, v√¨ khung l√† con c·ªßa mesh n√™n s·∫Ω theo aspect t·ª± nhi√™n
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.z = -0.08;
        border.scale.set(BORDER_PAD, BORDER_PAD, 1);
        mesh.add(border);

        mesh.visible = false;
        mesh.scale.set(0,0,0);

        // baseScale m·∫∑c ƒë·ªãnh n·∫øu ·∫£nh ch∆∞a load k·ªãp
        mesh.userData.baseScale = new THREE.Vector2(BASE_H, BASE_H);

        scene.add(mesh);
        photoMeshes.push(mesh);
        photoTextures.push(tex);

        // n·∫øu ·∫£nh ƒë√£ cache xong
        applyAspect(mesh, tex);
      }
    }

    function createDecorations() {
      const c = document.createElement('canvas');
      c.width = 1024; c.height = 256;
      const ctx = c.getContext('2d');
      ctx.font = 'bold italic 90px "Montserrat", sans-serif';
      ctx.fillStyle = '#D8B46A';
      ctx.textAlign = 'center';
      ctx.shadowColor = "rgba(255,80,80,0.55)";
      ctx.shadowBlur = 30;
      ctx.fillText("Y√™u Trang", 512, 130);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true, blending: THREE.AdditiveBlending });
      titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
      titleMesh.position.set(0, 50, 0);
      scene.add(titleMesh);

      const sc = document.createElement('canvas');
      sc.width = 128; sc.height = 128;
      const sCtx = sc.getContext('2d');
      sCtx.fillStyle = "#F2E3B5";
      sCtx.shadowColor="rgba(255,255,255,0.75)";
      sCtx.shadowBlur=18;
      sCtx.beginPath();
      const cx=64, cy=64, outer=50, inner=20;
      for(let i=0;i<5;i++){
        sCtx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*outer, cy - Math.sin((18+i*72)/180*Math.PI)*outer);
        sCtx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*inner, cy - Math.sin((54+i*72)/180*Math.PI)*inner);
      }
      sCtx.closePath(); sCtx.fill();

      const starTex = new THREE.CanvasTexture(sc);
      const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent:true, blending: THREE.AdditiveBlending });
      starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
      starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
      scene.add(starMesh);
    }

    function updateParticleGroupBlend(group, speed, time, isBlinking, tBlend){
      const pos = group.geometry.attributes.position.array;
      const fromT = getTargets(group.geometry, fromState);
      const toT   = getTargets(group.geometry, toState);

      for (let i=0; i<pos.length; i++){
        const target = fromT[i]*(1-tBlend) + toT[i]*tBlend;
        pos[i] += (target - pos[i]) * speed;
      }
      group.geometry.attributes.position.needsUpdate = true;

      if (toState === STATE.TREE){
        group.rotation.y += 0.003;
        if (isBlinking){
          // n·∫øu mu·ªën ch·∫≠m h∆°n ri√™ng red: ƒë·ªïi 5 -> 2.0
          const s = 1 + Math.sin(time*5) * 0.18;
          group.scale.set(s,s,s);
        } else group.scale.set(1,1,1);
      } else {
        group.scale.set(1,1,1);
      }
    }

    function updateRotationFromSwipe(dt){
      const decay = Math.exp(-CONFIG.frictionPerSec * dt);
      if (!active3D || !handSeen){
        lastHandX = null;
        rotVelocity *= decay;
        return;
      }

      if (lastHandX !== null){
        const dx = handX - lastHandX;
        rotVelocity += dx * CONFIG.swipeSensitivity;
        rotVelocity = clamp(rotVelocity, -CONFIG.velClamp, CONFIG.velClamp);
      }
      lastHandX = handX;

      rotVelocity *= decay;

      groupGold.rotation.y += rotVelocity;
      groupRed.rotation.y  += rotVelocity;
      groupGift.rotation.y += rotVelocity;
    }

    let lastT = performance.now();
    function animate(){
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = Math.min(0.033, (now - lastT)/1000);
      lastT = now;

      if (desiredState !== toState) requestState(desiredState);
      state = toState;

      let t = Math.min(1, (now - transStart)/CONFIG.transMs);
      t = smoothstep(t);

      const time = now * 0.001;
      const follow = 1 - Math.exp(-6.5 * dt);

      updateParticleGroupBlend(groupGold, follow, time, false, t);
      updateParticleGroupBlend(groupRed,  follow, time, true,  t);
      updateParticleGroupBlend(groupGift, follow, time, false, t);

      updateRotationFromSwipe(dt);

      if (state === STATE.TREE){
        titleMesh.visible = true; starMesh.visible = true;
        starMesh.rotation.z -= 0.02;
        photoMeshes.forEach(m=>{
          m.scale.lerp(new THREE.Vector3(0,0,0), 0.12);
          m.visible=false;
        });

      } else if (state === STATE.EXPLODE){
        titleMesh.visible = false; starMesh.visible = false;

        const baseAngle = groupGold.rotation.y;
        const angleStep = (Math.PI*2)/5;
        let bestIdx = 0, maxZ = -1e9;

        photoMeshes.forEach((mesh,i)=>{
          mesh.visible = true;

          const angle = baseAngle + i*angleStep;
          const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
          const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
          const y = Math.sin(time + i) * 3;

          mesh.position.lerp(new THREE.Vector3(x,y,z), 0.10);
          mesh.lookAt(camera.position);

          if (z > maxZ){ maxZ = z; bestIdx = i; }

          // ‚úÖ scale = baseScale * factor (kh√¥ng b·ªã b√© + kh√¥ng m√©o)
          const base = mesh.userData.baseScale || new THREE.Vector2(8,8);

          if (z > 5){
            const factor = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
            mesh.scale.lerp(new THREE.Vector3(base.x*factor, base.y*factor, 1), 0.10);
          } else {
            const factor = 0.6;
            mesh.scale.lerp(new THREE.Vector3(base.x*factor, base.y*factor, 1), 0.10);
          }
        });

        selectedIndex = bestIdx;

      } else if (state === STATE.PHOTO){
        photoMeshes.forEach((mesh,i)=>{
          const base = mesh.userData.baseScale || new THREE.Vector2(8,8);

          if (i === selectedIndex){
            mesh.visible = true;
            mesh.position.lerp(new THREE.Vector3(0,0,60), 0.10);

            // ‚úÖ gi·ªØ aspect khi ph√≥ng to
            mesh.scale.lerp(new THREE.Vector3(base.x*5, base.y*5, 1), 0.10);

            mesh.lookAt(camera.position);
            mesh.rotation.z = 0;
          } else {
            mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.12);
          }
        });
      }

      renderer.render(scene, camera);
    }

    let hands;

    function classifyGesture(avgDist, pinchDist){
      if (lastGesture === "PINCH") return (pinchDist < CONFIG.PINCH_OUT) ? "PINCH" : "OPEN";
      if (lastGesture === "FIST")  return (avgDist < CONFIG.FIST_OUT) ? "FIST" : "OPEN";

      if (avgDist < CONFIG.FIST_IN) return "FIST";
      if (pinchDist < CONFIG.PINCH_IN) return "PINCH";
      return "OPEN";
    }

    function updateStableGesture(g){
      const now = performance.now();
      if (g !== lastGesture){
        lastGesture = g;
        gestureSince = now;
      }
      if (now - gestureSince > CONFIG.gestureHoldMs){
        stableGesture = lastGesture;
      }
    }

    function applyGestureEdges(){
      const statusDiv = document.getElementById("status");
      if (stableGesture === prevStableGesture) return;

      if (stableGesture === "OPEN"){
        active3D = true;
        desiredState = STATE.EXPLODE;
        statusDiv.textContent = "üñê 3D ƒë√£ b·∫≠t ‚Ä¢ Vu·ªët ƒë·ªÉ xoay";
      }

      if (stableGesture === "PINCH"){
        if (active3D){
          desiredState = STATE.PHOTO;
          statusDiv.textContent = "üëå Xem ·∫£nh";
        }
      }

      if (stableGesture === "FIST"){
        active3D = false;
        desiredState = STATE.TREE;
        rotVelocity = 0;
        lastHandX = null;
        statusDiv.textContent = "‚úä ƒê√£ d·ª´ng ‚Ä¢ Thu c√¢y";
      }

      prevStableGesture = stableGesture;
    }

    async function startHands(){
      const video = document.getElementById("bg-video");
      if (!video) throw new Error("Kh√¥ng t√¨m th·∫•y <video id='bg-video'> trong HTML.");

      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height:{ ideal: 720 },
          aspectRatio: { ideal: 16/9 },
          facingMode: "user"
        },
        audio: false
      });

      video.srcObject = stream;
      await video.play();

      hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults((results)=>{
        handSeen = false;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
          handSeen = true;
          const lm = results.multiHandLandmarks[0];

          handX = lm[9].x;

          const tips = [8,12,16,20];
          const wrist = lm[0];
          let openDist = 0;
          for (const i of tips){
            openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y);
          }
          const avgDist = openDist/4;
          const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

          const g = classifyGesture(avgDist, pinchDist);
          updateStableGesture(g);
          applyGestureEdges();

          if (active3D && stableGesture !== "PINCH") desiredState = STATE.EXPLODE;

        } else {
          lastHandX = null;
          if (!active3D) document.getElementById("status").textContent = "üéÑ S·∫µn s√†ng";
        }
      });

      const pump = async () => {
        try { await hands.send({ image: video }); } catch(e) {}
        requestAnimationFrame(pump);
      };
      pump();
    }

    async function startSystem(){
      document.getElementById("btnStart").style.display = "none";
      try { await bgMusic.play(); } catch(e) {}

      init3D();
      animate();

      try { await startHands(); }
      catch(e){ logError(e); document.getElementById("status").textContent = "‚ö†Ô∏è Kh√¥ng m·ªü ƒë∆∞·ª£c camera"; }
    }

    document.getElementById("btnStart").addEventListener("click", startSystem);

    window.addEventListener("resize", ()=>{
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
